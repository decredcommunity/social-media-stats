#!/usr/bin/env python3

# tsu - time series utility

import os
import csv
import json
from collections import namedtuple
from datetime import datetime, timezone
from functools import partial
from itertools import chain
from urllib.parse import urlparse, urlunparse
import time


class Config:
    data_root_path          = "data"
    default_coll_data_path  = "data/accounts"
    default_coll_meta_path  = "data/accounts.json"
    export_outpath         = "export.csv"


class Const:
    int_exts            = (".csv", ".tsi")
    float_exts          = (".tsf", )
    str_exts            = (".tss", )
    numeric_types       = [int, float]


# Define and catch our own exception to avoid intercepting language and library
# exceptions.
class TsuError(Exception):
    pass


class ValidationError(TsuError):
    pass


def warn(template, *args):
    print("WARN: " + template.format(*args))


def parse_timestamp(s):
    try:
        tsi = int(s)
    except ValueError as e:
        raise ValidationError(
            "timestamp is not an integer: '{}'".format(s)) from e
    try:
        dt = datetime.utcfromtimestamp(tsi)
    except Exception as e:
        raise ValidationError(
            "cannot parse datetime from timestamp: '{}'".format(tsi)) from e
    return dt


def parse_int(s):
    try:
        return int(s)
    except ValueError as e:
        raise ValidationError(
            "value is not an integer: '{}'".format(s)) from e


def parse_float(s):
    try:
        return float(s)
    except ValueError as e:
        raise ValidationError(
            "value is not a float: '{}'".format(s)) from e


def parse_record(rec, valtype):
    if len(rec) != 2:
        raise ValidationError(
            "record must have exactly 2 fields: " + str(rec))
    s1, s2 = rec

    dt = parse_timestamp(s1)

    if valtype == int:
        val = parse_int(s2)
    elif valtype == float:
        val = parse_float(s2)
    else:
        if len(s2) > 0:
            val = s2
        else:
            raise ValidationError("value is empty")
    return dt, val


def value_type(path):
    ext = os.path.splitext(path)[1]
    if ext in Const.int_exts:
        return int
    elif ext in Const.float_exts:
        return float
    elif ext in Const.str_exts:
        return str
    else:
        return None


def is_known_type(path):
    return value_type(path) is not None


def is_numeric_type(path):
    return value_type(path) in Const.numeric_types


def csv_iter(path):
    """Generator yielding rows of the csv file."""
    with open(path, newline="") as f:
        yield from csv.reader(f)


def write_csv(path, rows):
    # overwrite existing file
    with open(path, "w", newline="") as f:
        writer = csv.writer(f, quoting=csv.QUOTE_MINIMAL, lineterminator="\n")
        writer.writerows(rows)


def print_record(dt, val, valtype):
    if valtype == int:
        print(dt, "{:>6,}".format(val))
    else:
        print(dt, val)


def validate(path, view=False, limit=None):
    valtype = value_type(path)
    prev_dt = datetime.min
    all_rows = list(csv_iter(path))
    first = 0
    rows = all_rows
    if limit is not None:
        first = max(len(all_rows) - limit, 0)
        rows = all_rows[first:]

    # start counting from 1 to match file line number
    for line_num, row in enumerate(rows, start=first + 1):
        try:
            dt, val = parse_record(row, valtype)
            if dt <= prev_dt:
                raise ValidationError(
                    "timestamp '{}' must be greater than '{}'".format(dt, prev_dt))
            prev_dt = dt
            if view:
                print_record(dt, val, valtype)
        except ValidationError as e:
            print("err {}:{}: {}".format(path, line_num, e))


def file_paths_sorted(root, pred, filter_root=True, error=True):
    paths = []
    if os.path.isfile(root):
        # filter_root=False allows a uniform interface for handling two
        # different cases. When a caller (indirectly it is the user)
        # _knows_ that root is a file that must be used regardless of
        # its type, predicate check is skipped. However, when root is a
        # directory that must be walked, the caller (user) wants the
        # discovered files to be filtered with pred.
        root_ok = pred(root)
        if (not filter_root) or root_ok:
            paths.append(root)
        if not root_ok:
            warn("test {} failed for: {}", pred.__name__, root)

    elif os.path.isdir(root):
        for curdir, dirs, files in os.walk(root):
            for fname in files:
                if pred(fname):
                    paths.append(os.path.join(curdir, fname))

    else:
        if error:
            raise TsuError("path is neither a file nor a directory: " + root)
        else:
            warn("path is neither a file nor a directory: {}", root)

    return sorted(paths)


def cmd_view(args):
    limit = args.limit
    int_limit = None
    if limit is not None:
        try:
            int_limit = int(limit)
        except ValueError as e:
            raise TsuError("limit is not an integer: '{}'".format(limit)) from e

    root = args.path
    for fp in file_paths_sorted(root, pred=is_known_type, filter_root=False):
        print("----", fp)
        validate(fp, view=True, limit=int_limit)


# Path-related terminology used below is better explained in one place:
# 
# - collection - a set of data of (mostly) the same type and structure.
#   Currently, tsu can only handle a collection that is a hierarchy of
#   time series files.
# - rpath - real path to a file or directory, used to read/write data
#   on the file system.
# - icpath - "in-collection path" that is relative to the collection
#   directory and always uses slash `/` as path separator. icpaths are
#   used to derive metadata and also in various lists for
#   mass-processing accounts and metrics. These paths are very local by
#   design for greater flexibility, i.e. they don't hardcode a
#   collection they are included in.
# - account - a group of metrics, plus account-wide metadata common for
#   all metrics.
# - account meta - information that helps to track and process account's
#   metrics, like account's URL, creation date, tags, etc.
# - account path - icpath where account's metrics are stored.
# - metric - a *single* value we track for the account. Keeping each
#   metric in its own time series makes them simple and composable.
# - metric meta - information that helps to work with the metric. Most
#   importantly it is the account the metric belongs to, which in turn
#   allows to load account meta to capture new values.


MetricMeta = namedtuple("MetricMeta", [
    "rpath",
    "name",
    "platform",
    "account",
    "account_path",
    "account_meta",
])


def cmd_latest(args):
    coll_data_root = args.colldata

    metric_icpaths = load_list(args.metriclist)
    if not metric_icpaths:
        return

    metfmt = "{:20}|{:24}|{:24}"
    headerfmt = metfmt + "|{:20}|{:7}"
    print(headerfmt.format("platform", "account", "metric", "date", "value"))
    print("{:-<20}|{:-<24}|{:-<24}|{:-<20}|{:-<7}".format("", "", "", "", ""))

    for met_icpath in metric_icpaths:
        # resolve met_icpath against the collection to get the real path
        met_rpath = os.path.join(coll_data_root, met_icpath)
        if not os.path.isfile(met_rpath):
            warn("not a file: {}", met_rpath)
            continue
        rows = list(csv_iter(met_rpath))
        if len(rows) < 1:
            warn("no data: {}", met_rpath)
            continue
        valtype = value_type(met_rpath)
        last_dt, last_val = parse_record(rows[-1], valtype)
        mm = metric_meta(met_rpath, met_icpath)
        if mm:
            metstr = metfmt.format(mm.platform, mm.account, mm.name)
        else:
            metstr = "{:68}".format(met_icpath)
        print("{}|{:20}|{:>7,}".format(metstr, str(last_dt), last_val))


def cmd_list_accounts(args):
    for acc in load_json(args.collmeta):
        print(acc["path"])


def cmd_validate(args):
    root = args.path
    for fp in file_paths_sorted(root, pred=is_known_type, filter_root=False):
        validate(fp)


def load_list(path):
    with open(path) as f:
        return [line.rstrip("\n") for line in f]


def index_list(list, key):
    res = {}
    for item in list:
        ik = item.get(key)
        if ik is None:
            raise TsuError("missing value for key '{}'".format(key))
        if ik in res:
            raise TsuError("duplicate value '{}' for key '{}'".format(ik, key))
        res[ik] = item
    return res


def metric_meta(rpath, icpath, coll_meta=None):
    # to have met_name in more cases, take it from rpath and not from
    # icpath
    _dirname, filename = os.path.split(rpath)
    met_name, _ext = os.path.splitext(filename)

    # Example `icpath`: `github.com/decred/dcrd/forks.csv`
    # Here `github.com` is the platform, `decred/dcrd` is the account,
    # and `forks` is the metric.
    # Therefore, `icpath` normally has 3 parts (minimum), 4 for
    # two-level accounts like on github.com, and possibly more.
    # icpath MUST only use `/` path separator and MUST be relative to
    # collection data dir, i.e. must not include any parts above
    # platform, i.e. not be concerned in what collection it is placed.

    plat, acc, acc_path = None, None, None
    if icpath is not None:
        # todo: test how `/` in metric paths would work on Windows
        parts = icpath.split("/")
        icpath_valid = len(parts) >= 3
        if icpath_valid:
            plat, *acc_parts, _filename = parts
            acc = "/".join(acc_parts)
            acc_path = plat + "/" + acc
        else:
            warn("icpath was given but it has <= 3 parts: {}", icpath)

    acc_meta = None
    if (coll_meta is not None) and (acc_path is not None):
        acc_meta = coll_meta[acc_path]

    return MetricMeta(rpath=rpath, name=met_name,
                      platform=plat, account=acc, account_path=acc_path,
                      account_meta=acc_meta)


def export_append_rows(rows, met_meta):
    if value_type(met_meta.rpath) is None:
        warn("exporting from unknown file type: {}", met_meta.rpath)

    tags = ""
    acc_meta = met_meta.account_meta
    if acc_meta:
        if "tags" in acc_meta:
            tags = " ".join(acc_meta["tags"])
    else:
        warn("missing account meta for acc path: {}", met_meta.account_path)

    for ts, val in csv_iter(met_meta.rpath):
        rows.append((ts, met_meta.platform, met_meta.account, met_meta.name,
                     val, tags))


def export_csv(coll_data_root, coll_meta, export_icpaths, outpath):
    rows = []
    exported_files = 0
    skipped_paths = 0

    for export_icpath in export_icpaths:
        # resolve the in-collection path with its data dir
        rpath = os.path.join(coll_data_root, export_icpath)
        # if any path explicitly specified by the user is a file, try
        # exporting it regardless of its type
        # otherwise, filter the walked (discovered indirectly) paths
        # and only take time series files with numeric values
        for met_rpath in file_paths_sorted(rpath, pred=is_numeric_type,
                                           filter_root=False, error=False):
            met_icpath = os.path.relpath(met_rpath, coll_data_root)
            met_meta = metric_meta(met_rpath, met_icpath, coll_meta)
            if (not met_meta.platform) or (not met_meta.account):
                warn("unknown platform/account, skipping path: {}", met_rpath)
                skipped_paths += 1
                continue # for met_rpath ...
            export_append_rows(rows, met_meta)
            exported_files += 1

    # sort by timestamp (first row cell), in-place
    rows.sort()
    print("exporting {} data points from {} files (skipped {} paths)"
          "".format(len(rows), exported_files, skipped_paths))

    header = ("timestamp", "platform", "account", "metric", "value", "tags")

    # overwrite existing file
    write_csv(outpath, chain([header], rows))
    print("file saved:", outpath)


def cmd_export_csv(args):
    # try loading the meta to possibly trigger FileNotFoundError earlier
    coll_meta = load_json(args.collmeta)
    coll_meta_indexed = index_list(coll_meta, key="path")

    pathlist = args.pathlist
    if pathlist:
        # pathlist items MUST be relative to the collection data dir
        export_paths = load_list(pathlist)
        print("exporting {} paths listed in: {}"
              "".format(len(export_paths), pathlist))
    else:
        # for the user the most intuitive thing is to tab-complete a
        # real file system path and pass it as the `path` argument,
        # without ever thinking about our icpath/rpath magic.
        # therefore, we must convert user-specified path (rpath) to one
        # that is properly based off the collection data dir (icpath)
        # todo: normalize path passed via CLI into an in-collection path
        warn("make sure path is relative to the collection or use --pathlist!")
        path = args.path
        export_paths = [path]
        print("exporting all metrics under:", path)

    export_csv(args.colldata, coll_meta_indexed, export_paths, args.outpath)


def load_json(path):
    with open(path) as f:
        return json.load(f)


def replace_url(url):
    # replace some URLs for easier data point collection
    pu = urlparse(url)
    if pu.netloc == "twitter.com":
        newpu = pu._replace(netloc="nitter.eu")
        newurl = urlunparse(newpu)
        return newurl
    return url


def make_hint(met_meta, default_hint):
    hint = ""
    acc_meta = met_meta.account_meta
    if acc_meta:
        if "name" in acc_meta:
            hint += '"' + acc_meta["name"] + '"'
        if "url" in acc_meta:
            if hint:
                hint += " "
            hint += replace_url(acc_meta["url"])

    return hint if hint else default_hint


class SpecialValue:
    pass


class InputCancel(SpecialValue):
    pass


def optional_input(prompt, input):
    """Read a string, cancel if blank line entered twice.

    Use the passed input function for reading. Return an InputCancel
    instance to signal cancellation by the user.
    """
    try:
        s = input(prompt)
        if s == "":
            s = input("enter blank again to skip or a value to continue: ")
            if s == "":
                return InputCancel()
        return s
    except EOFError:
        print("(got EOF)")
        return InputCancel()


class Command(SpecialValue):
    pass


class TimestampCommand(Command):
    pass


def command_input(prompt, input):
    """Read a string and optionally map it to a Command instance.

    Use the passed input function for reading. If the read value starts
    with colon (:), translate it to an appropriate Command instance.
    """
    inp = input(prompt)
    if isinstance(inp, str) and inp.startswith(":"):
        if inp == ":t":
            return TimestampCommand()
        else:
            raise ValueError("unknown command '{}'".format(inp))
    else:
        return inp


def confirmed_input(prompt, confirm_prompt, input):
    """Read inputs until two subsequent inputs match.

    Use the passed input function for reading. If the input function
    returns a SpecialValue instance, return it as is without a
    confirmation input.
    """
    inp = input(prompt)
    if isinstance(inp, SpecialValue):
        return inp

    prev = inp
    # keep collecting inputs until (a) two inputs match OR (b) input is
    # canceled
    while True:
        cur = input(confirm_prompt)
        if (cur == prev) or isinstance(cur, SpecialValue):
            return cur
        prev = cur


def validated_input(prompt, converter, printer, input):
    while True:
        try:
            inp = input(prompt)
            if isinstance(inp, SpecialValue):
                return inp
            return converter(inp)
        except ValidationError as e:
            printer("error: {}".format(str(e)))


def parse_date(date_string, format):
    # extend datetime.strptime formats with %s from the `date` program
    if format == "%s":
        return parse_timestamp(date_string)
    else:
        try:
            return datetime.strptime(date_string, format)
        except ValueError as e:
            raise ValidationError(
                "cannot parse datetime from: '{}'".format(date_string)) from e


def datetime_converter(s):
    dt = None
    for f in ["%d %b %Y %H:%M:%S", "%Y-%m-%d %H:%M:%S", "%s"]:
        try:
            dt = parse_date(s, f)
            break
        except ValidationError:
            pass

    if not dt:
        raise ValidationError("unrecognized date value: " + s)

    return dt


def datetime_greater(other):
    def validator(s):
        dt = datetime_converter(s)
        if dt > other:
            return dt
        else:
            raise ValidationError("timestamp must be greater than " + str(other))
    return validator


def make_input(prefix, typedesc, converter, printer):
    # Use function composition to build a powerful input function.
    # Simpler input functions will run (and handle user's input) in the
    # following order: optional_input -> command_input ->
    # validated_input -> confirmed_input.
    cancelable = partial(optional_input, input=input)
    command = partial(command_input, input=cancelable)
    validated = partial(validated_input, converter=converter, printer=printer,
                        input=command)
    prompt = prefix + "enter {} value: ".format(typedesc)
    confirm_prompt = prefix + "confirm {} value: ".format(typedesc)
    confirmed = partial(confirmed_input, prompt, confirm_prompt, validated)
    return confirmed


def timestamp_input(prefix, min_ts, printer):
    converter = datetime_greater(min_ts) if min_ts else datetime_converter
    input = make_input(prefix, "timestamp", converter, printer)
    while True:
        inp = input()
        if isinstance(inp, Command):
            printer("error: commands are not allowed while entering timestamp")
        else:
            return inp


def identity(x):
    return x


def make_prompt_prefix(met_meta):
    prefix = met_meta.name
    if met_meta.account:
        prefix = met_meta.account + "/" + met_meta.name
    return prefix + ": "


def entry_file(met_meta):
    _dir, filename = os.path.split(met_meta.rpath)

    prompt_prefix = make_prompt_prefix(met_meta)
    printer = lambda s: print(prompt_prefix + s)

    hint = make_hint(met_meta, default_hint=met_meta.rpath)
    printer("capture the value for " + hint)

    valtype = value_type(filename)
    rows = list(csv_iter(met_meta.rpath)) # read all to get the length
    last_dt, last_val = None, None
    if len(rows) > 0:
        last_dt, last_val = parse_record(rows[-1], valtype)
        # extra output for a sanity check
        printer("last record is: time {}, value {}".format(last_dt, last_val))

    if valtype == int:
        input = make_input(prompt_prefix, "integer", parse_int, printer)
    elif valtype == float:
        input = make_input(prompt_prefix, "float", parse_float, printer)
    elif valtype == str:
        input = make_input(prompt_prefix, "string", identity, printer)
    else:
        # use Exception over TsuError to force traceback printing
        raise Exception("unexpected value type: " + str(valtype))

    dt_custom = None
    while True: # main entry loop
        inp = input()
        dt = dt_custom if dt_custom else datetime.utcnow().replace(microsecond=0)
        if isinstance(inp, InputCancel):
            printer("skipping")
            return
        elif isinstance(inp, TimestampCommand):
            dt_inp = timestamp_input(prompt_prefix, last_dt, printer)
            if isinstance(dt_inp, datetime):
                printer("using timestamp {} for current metric only".format(dt_inp))
                dt_custom = dt_inp
            elif isinstance(dt_inp, InputCancel):
                printer("timestamp entry canceled")
        elif isinstance(inp, SpecialValue):
            # use Exception over TsuError to force traceback printing
            raise Exception("unexpected SpecialValue: " + str(inp))
        else:
            val = inp
            break # main entry loop

    if valtype == int and last_val:
        delta = " ({:+})".format(val - last_val)
    else:
        delta = ""

    ts = int(dt.replace(tzinfo=timezone.utc).timestamp())
    rows.append((ts, val))
    write_csv(met_meta.rpath, rows)
    printer("saved: time {}, value {}{}".format(dt, val, delta))


def entry_path(entry_icpath, coll_data_root, coll_meta):
    # resolve the in-collection path with collection data dir
    entry_rpath = os.path.join(coll_data_root, entry_icpath)
    # unlike the other places, here we DO filter the root path.
    # if it is a file, and not of a numeric type, we won't know how to
    # properly add data to it
    for met_rpath in file_paths_sorted(entry_rpath, pred=is_numeric_type,
                                       filter_root=True, error=False):
        met_icpath = os.path.relpath(met_rpath, coll_data_root)
        met_meta = metric_meta(met_rpath, met_icpath, coll_meta)
        entry_file(met_meta)


def cmd_entry(args):
    """Enter data manually in an interactive session.

    You will be prompted to enter data points one by one for each
    applicable file. After collecting the input value, UTC timestamp
    will be generated and appended to the end of file together with the
    new value. Make sure your system clock is accurate.

    To protect from errors, you will be prompted to enter each value
    twice.

    To skip entering current value, enter a blank line twice or hit
    Ctrl-D (Ctl-Z+Return on Windows).

    To enter the timestamp manually, enter ':t' instead of the value.

    To quit the data entry session, hit Ctrl-C.
    """
    # try loading the meta to possibly trigger FileNotFoundError earlier
    coll_meta = load_json(args.collmeta)
    coll_meta_indexed = index_list(coll_meta, "path")

    pathlist = args.pathlist
    if pathlist:
        # pathlist items MUST be relative to the collection data dir
        paths = load_list(pathlist)
    else:
        # todo: normalize path passed via CLI into an in-collection path
        warn("make sure path is relative to the collection or use --pathlist!")
        paths = [args.path]

    print("Interactive data entry mode. Make sure your system clock is accurate.")
    print("Your system UTC time is:",
          format(datetime.utcfromtimestamp(int(time.time()))))

    for path in paths:
        entry_path(path, args.colldata, coll_meta_indexed)


def make_arg_parser():
    import argparse

    file_types_str = ", ".join(Const.int_exts + Const.float_exts + Const.str_exts)
    parser = argparse.ArgumentParser(
        description=("time series utility. The following file types are"
                     " supported: " + file_types_str))

    # -m and -d mean that only ONE collection can be handled at a time

    parser.add_argument(
        "-m", "--collmeta",
        default=Config.default_coll_meta_path,
        help="path to collection metadata JSON file (default: {})"
             "".format(Config.default_coll_meta_path))

    parser.add_argument(
        "-d", "--colldata",
        default=Config.default_coll_data_path,
        help="path to collection data directory (default: {})"
             "".format(Config.default_coll_data_path))

    subparsers = parser.add_subparsers(dest="command", title="commands")

    listaccs = subparsers.add_parser(
        "listaccs", aliases=["la"],
        help="list accounts in the JSON metadata file. -m is required if its"
             " default does not exist.")
    listaccs.set_defaults(func=cmd_list_accounts)

    validate = subparsers.add_parser(
        "validate", aliases=["val"],
        help="validate time series files")
    validate.add_argument(
        "path", nargs="?",
        default=Config.data_root_path,
        help="path to search time series files")
    validate.set_defaults(func=cmd_validate)

    view = subparsers.add_parser(
        "view", aliases=["v"],
        help="view one or more time series files")
    view.add_argument(
        "path",
        help="path to view")
    view.add_argument(
        "-l", "--limit",
        help="max number of records to output for each file")
    view.set_defaults(func=cmd_view)

    latest = subparsers.add_parser(
        "latest",
        help="print latest values for metrics listed in a file. -d is required"
             " if its default does not exist.")
    latest.add_argument(
        "metriclist",
        help="list file with metric files to report, one per line")
    latest.set_defaults(func=cmd_latest)

    export = subparsers.add_parser(
        "export",
        help="export data into a single CSV file. -m and -d are required if"
             " their defaults do not exist.",
        description=("Export data from arbitrary tree of time series files"
                     " into a single file (" + Config.export_outpath +
                     " by default), overwriting it."))
    export_src = export.add_mutually_exclusive_group(required=True)
    export_src.add_argument(
        "path", nargs="?",
        default=Config.default_coll_data_path,
        help="path to export data points from")
    export_src.add_argument(
        "-p", "--pathlist",
        help="list file with paths to export data points from, one per line")
    export.add_argument(
        "--outpath",
        default=Config.export_outpath,
        help="file path to save")
    export.set_defaults(func=cmd_export_csv)

    entry = subparsers.add_parser(
        "entry", aliases=["e"],
        help="enter data manually. -m and -d are required if their defaults"
             " do not exist",
        description=cmd_entry.__doc__)
    entry_target = entry.add_mutually_exclusive_group(required=True)
    entry_target.add_argument(
        "path", nargs="?",
        default=Config.default_coll_data_path,
        help="file or directory path to enter data in; if directory, the"
             " program will prompt for data entry for each time series file"
             " found in it")
    entry_target.add_argument(
        "-p", "--pathlist",
        help="list file with paths to enter data in, one path per line")
    entry.set_defaults(func=cmd_entry)

    return parser


def main():
    parser = make_arg_parser()
    args = parser.parse_args()

    if args.command:
        try:
            args.func(args)
        except (TsuError, FileNotFoundError) as e:
            print("error:", e)
        except KeyboardInterrupt:
            print("\naborting")
        except BrokenPipeError:
            # silence error when e.g. piping into `less` and quitting before
            # reading all
            pass
    else:
        parser.print_usage()


if __name__ == "__main__":
    main()
