#!/usr/bin/env python3

# tsu - time series utility

import os
import csv
import json
from datetime import datetime, timezone
from functools import partial
from itertools import chain
from urllib.parse import urlparse, urlunparse
import time


class Config:
    data_dir            = "data/data"
    export_filename     = "export.csv"
    account_filename    = "profile.json"


class Const:
    int_exts            = (".csv", ".tsi")
    float_exts          = (".tsf", )
    str_exts            = (".tss", )
    numeric_types       = [int, float]


# Define and catch our own exception to avoid intercepting language and library
# exceptions.
class TsuError(Exception):
    pass


class ValidationError(TsuError):
    pass


def warn(template, *args):
    print("WARN: " + template.format(*args))


def parse_timestamp(s):
    try:
        tsi = int(s)
    except ValueError as e:
        raise ValidationError(
            "timestamp is not an integer: '{}'".format(s)) from e
    try:
        dt = datetime.utcfromtimestamp(tsi)
    except Exception as e:
        raise ValidationError(
            "cannot parse datetime from timestamp: '{}'".format(tsi)) from e
    return dt


def parse_int(s):
    try:
        return int(s)
    except ValueError as e:
        raise ValidationError(
            "value is not an integer: '{}'".format(s)) from e


def parse_float(s):
    try:
        return float(s)
    except ValueError as e:
        raise ValidationError(
            "value is not a float: '{}'".format(s)) from e


def parse_record(rec, valtype):
    if len(rec) != 2:
        raise ValidationError(
            "record must have exactly 2 fields: " + str(rec))
    s1, s2 = rec

    dt = parse_timestamp(s1)

    if valtype == int:
        val = parse_int(s2)
    elif valtype == float:
        val = parse_float(s2)
    else:
        if len(s2) > 0:
            val = s2
        else:
            raise ValidationError("value is empty")
    return dt, val


def value_type(path):
    ext = os.path.splitext(path)[1]
    if ext in Const.int_exts:
        return int
    elif ext in Const.float_exts:
        return float
    elif ext in Const.str_exts:
        return str
    else:
        return None


def is_known_type(path):
    return value_type(path) is not None


def is_numeric_type(path):
    return value_type(path) in Const.numeric_types


def csv_iter(path):
    """Generator yielding rows of the csv file."""
    with open(path, newline="") as f:
        yield from csv.reader(f)


def write_csv(path, rows):
    # overwrite existing file
    with open(path, "w", newline="") as f:
        writer = csv.writer(f, quoting=csv.QUOTE_MINIMAL, lineterminator="\n")
        writer.writerows(rows)


def print_record(dt, val, valtype):
    if valtype == int:
        print(dt, "{:>6,}".format(val))
    else:
        print(dt, val)


def validate(path, view=False, limit=None):
    valtype = value_type(path)
    prev_dt = datetime.min
    all_rows = list(csv_iter(path))
    first = 0
    rows = all_rows
    if limit is not None:
        first = max(len(all_rows) - limit, 0)
        rows = all_rows[first:]

    # start counting from 1 to match file line number
    for line_num, row in enumerate(rows, start=first + 1):
        try:
            dt, val = parse_record(row, valtype)
            if dt <= prev_dt:
                raise ValidationError(
                    "timestamp '{}' must be greater than '{}'".format(dt, prev_dt))
            prev_dt = dt
            if view:
                print_record(dt, val, valtype)
        except ValidationError as e:
            print("err {}:{}: {}".format(path, line_num, e))


def file_paths_sorted(root, pred, filter_root=True, error=True):
    paths = []
    if os.path.isfile(root):
        # filter_root=False allows a uniform interface for handling two
        # different cases. When a caller (indirectly it is the user)
        # _knows_ that root is a file that must be used regardless of
        # its type, predicate check is skipped. However, when root is a
        # directory that must be walked, the caller (user) wants the
        # discovered files to be filtered with pred.
        root_ok = pred(root)
        if (not filter_root) or root_ok:
            paths.append(root)
        if not root_ok:
            warn("test {} failed for: {}", pred.__name__, root)

    elif os.path.isdir(root):
        for curdir, dirs, files in os.walk(root):
            for fname in files:
                if pred(fname):
                    paths.append(os.path.join(curdir, fname))

    else:
        if error:
            raise TsuError("path is neither a file nor a directory: " + root)
        else:
            warn("path is neither a file nor a directory: {}", root)

    return sorted(paths)


def cmd_view(args):
    limit = args.limit
    int_limit = None
    if limit is not None:
        try:
            int_limit = int(limit)
        except ValueError as e:
            raise TsuError("limit is not an integer: '{}'".format(limit)) from e

    root = args.path
    for fp in file_paths_sorted(root, pred=is_known_type, filter_root=False):
        print("----", fp)
        validate(fp, view=True, limit=int_limit)


def cmd_latest(args):
    metric_paths = load_list(args.metriclist)
    if not metric_paths:
        return
    metfmt = "{:20}|{:24}|{:24}"
    headerfmt = metfmt + "|{:20}|{:7}"
    print(headerfmt.format("platform", "account", "metric", "date", "value"))
    print("{:-<20}|{:-<24}|{:-<24}|{:-<20}|{:-<7}".format("", "", "", "", ""))
    for mp in metric_paths:
        if not os.path.isfile(mp):
            warn("not a file: {}", mp)
            continue
        rows = list(csv_iter(mp))
        if len(rows) < 1:
            warn("no data: {}", mp)
            continue
        valtype = value_type(mp)
        last_dt, last_val = parse_record(rows[-1], valtype)
        attrs = metric_attrs(mp)
        if attrs:
            metstr = metfmt.format(*attrs)
        else:
            metstr = "{:68}".format(mp)
        print("{}|{:20}|{:>7,}".format(metstr, str(last_dt), last_val))


def cmd_list_accounts(args):
    root = Config.data_dir

    # if the directory contains the account descriptor, it is an account
    acc_files = file_paths_sorted(root,
        pred=lambda fname: fname == Config.account_filename)
    acc_dirs = list(map(os.path.dirname, acc_files))

    for ad in acc_dirs:
        print(ad)


def cmd_validate(args):
    root = args.path
    for fp in file_paths_sorted(root, pred=is_known_type, filter_root=False):
        validate(fp)


def load_list(path):
    with open(path) as f:
        return [line.rstrip("\n") for line in f]


def strip_prefix(s, p):
    if s.startswith(p):
        return s[len(p):]
    else:
        return s


def load_acc_meta(dirpath):
    apath = os.path.join(dirpath, Config.account_filename)
    if os.path.exists(apath):
        return load_json(apath)
    else:
        return None


def metric_attrs(path):
    prefix = Config.data_dir + os.sep
    if not path.startswith(prefix):
        # didn't consider this case thoroughly
        return None
    innerpath = strip_prefix(path, prefix)
    parts = innerpath.split(os.sep)
    valid = len(parts) >= 3
    if not valid:
        return None
    # platform is the first path component under Config.data_dir
    # account is 1+ path components under platform, except the last one
    platform, *account, metric_ext = parts
    account_str = "/".join(account)
    # metric name is the file name without extension
    metric = os.path.splitext(metric_ext)[0]
    return platform, account_str, metric


def export_append_rows(rows, fpath):
    if value_type(fpath) is None:
        warn("exporting from unknown file type: {}", fpath)

    # Return True if data was exported from fpath into rows, False if
    # skipped.
    attrs = metric_attrs(fpath)
    if not attrs:
        warn("could not derive (platform, account, metric), skipping path: {}",
             fpath)
        return False

    platform, account, metric = attrs
    tags = ""
    acc_meta = load_acc_meta(os.path.dirname(fpath))
    if acc_meta and ("tags" in acc_meta):
        tags = " ".join(acc_meta["tags"])
    for ts, val in csv_iter(fpath):
        rows.append((ts, platform, account, metric, val, tags))
    return True


def export_csv(roots, outname):
    rows = []
    exported_paths = 0
    skipped_paths = 0

    for root in roots:
        # if any path explicitly specified by the user is a file, try
        # exporting it regardless of its type
        # otherwise, filter the walked (discovered indirectly) paths
        # and only take time series files with numeric values
        for fp in file_paths_sorted(root, pred=is_numeric_type,
                                    filter_root=False, error=False):
            ok = export_append_rows(rows, fp)
            if ok:
                exported_paths += 1
            else:
                skipped_paths += 1

    # sort by timestamp (first row cell), in-place
    rows.sort()
    print("exporting {} data points from {} files (skipped {} paths)"
          "".format(len(rows), exported_paths, skipped_paths))

    header = ("timestamp", "platform", "account", "metric", "value", "tags")

    # overwrite existing file
    write_csv(outname, chain([header], rows))
    print("file saved:", outname)


def cmd_export_csv(args):
    pathlist = args.pathlist

    if pathlist:
        roots = load_list(pathlist)
        print("exporting {} paths listed in: {}".format(len(roots), pathlist))
    else:
        path = args.path
        roots = [path]
        print("exporting all paths under:", path)

    export_csv(roots, args.output)


def load_json(path):
    with open(path) as f:
        return json.load(f)


def replace_url(url):
    # replace some URLs for easier data point collection
    pu = urlparse(url)
    if pu.netloc == "twitter.com":
        newpu = pu._replace(netloc="nitter.eu")
        newurl = urlunparse(newpu)
        return newurl
    return url


def make_hint(dirpath, default_hint):
    acc_meta = load_acc_meta(dirpath)
    hint = ""
    if acc_meta:
        if "name" in acc_meta:
            hint += '"' + acc_meta["name"] + '"'
        if "url" in acc_meta:
            if hint:
                hint += " "
            hint += replace_url(acc_meta["url"])

    return hint if hint else default_hint


class SpecialValue:
    pass


class InputCancel(SpecialValue):
    pass


def optional_input(prompt, input):
    """Read a string, cancel if blank line entered twice.

    Use the passed input function for reading. Return a value or an
    InputCancel instance to signal cancellation by the user.
    """
    try:
        s = input(prompt)
        if s == "":
            s = input("enter blank again to skip or a value to continue: ")
            if s == "":
                return InputCancel()
        return s
    except EOFError:
        print("(got EOF)")
        return InputCancel()


class Command(SpecialValue):
    pass


class TimestampCommand(Command):
    pass


def command_input(prompt, input):
    inp = input(prompt)
    if isinstance(inp, str) and inp.startswith(":"):
        if inp == ":t":
            return TimestampCommand()
        else:
            raise ValueError("unknown command '{}'".format(inp))
    else:
        return inp


def confirmed_input(prompt, confirm_prompt, input):
    """Read inputs until two subsequent inputs match, cancel on blank input.

    If user cancels input, return what optional_input returned.
    """
    inp = input(prompt)
    if isinstance(inp, SpecialValue):
        return inp

    prev = inp
    # keep collecting inputs until (a) two inputs match or (b) input is canceled
    while True:
        cur = input(confirm_prompt)
        if (cur == prev) or isinstance(cur, SpecialValue):
            return cur
        prev = cur


def validated_input(prompt, converter, printer, input):
    while True:
        try:
            inp = input(prompt)
            if isinstance(inp, SpecialValue):
                return inp
            return converter(inp)
        except ValidationError as e:
            printer("error: {}".format(str(e)))


def parse_date(date_string, format):
    # extend datetime.strptime formats with %s from the `date` program
    if format == "%s":
        return parse_timestamp(date_string)
    else:
        try:
            return datetime.strptime(date_string, format)
        except ValueError as e:
            raise ValidationError(
                "cannot parse datetime from: '{}'".format(date_string)) from e


def datetime_converter(s):
    dt = None
    for f in ["%d %b %Y %H:%M:%S", "%Y-%m-%d %H:%M:%S", "%s"]:
        try:
            dt = parse_date(s, f)
            break
        except ValidationError:
            pass

    if not dt:
        raise ValidationError("unrecognized date value: " + s)

    return dt


def datetime_greater(other):
    def validator(s):
        dt = datetime_converter(s)
        if dt > other:
            return dt
        else:
            raise ValidationError("timestamp must be greater than " + str(other))
    return validator


def make_input(prefix, typedesc, converter, printer):
    cancelable = partial(optional_input, input=input)
    command = partial(command_input, input=cancelable)
    validated = partial(validated_input, converter=converter, printer=printer,
                        input=command)
    initial_prompt = prefix + "enter {} value: ".format(typedesc)
    confirm_prompt = prefix + "confirm {} value: ".format(typedesc)
    return partial(confirmed_input, initial_prompt, confirm_prompt, validated)


def timestamp_input(prefix, min_ts, printer):
    converter = datetime_greater(min_ts) if min_ts else datetime_converter
    input = make_input(prefix, "timestamp", converter, printer)
    while True:
        inp = input()
        if isinstance(inp, Command):
            printer("error: commands are not allowed while entering timestamp")
        else:
            return inp


def identity(x):
    return x


def make_prompt_prefix(path):
    attrs = metric_attrs(path)
    if not attrs:
        warn("could not determine account/metric for: {}", path)
        return "n/a"
    _, account, metric = attrs
    return account + "/" + metric


def entry_file(path):
    dirpath, filename = os.path.split(path)

    prompt_prefix = make_prompt_prefix(path) + ": "
    printer = lambda s: print(prompt_prefix + s)

    hint = make_hint(dirpath, filename)
    printer("capture the value for " + hint)

    valtype = value_type(filename)
    rows = list(csv_iter(path)) # read all to get the length
    last_dt, last_val = None, None
    if len(rows) > 0:
        last_dt, last_val = parse_record(rows[-1], valtype)
        # extra output for a sanity check
        printer("last record is: time {}, value {}".format(last_dt, last_val))

    if valtype == int:
        input = make_input(prompt_prefix, "integer", parse_int, printer)
    elif valtype == float:
        input = make_input(prompt_prefix, "float", parse_float, printer)
    elif valtype == str:
        input = make_input(prompt_prefix, "string", identity, printer)
    else:
        raise Exception("unexpected value type: " + str(valtype))

    dt_custom = None
    while True: # main entry loop
        inp = input()
        dt = dt_custom if dt_custom else datetime.utcnow().replace(microsecond=0)
        if isinstance(inp, InputCancel):
            printer("skipping")
            return
        elif isinstance(inp, TimestampCommand):
            dt_inp = timestamp_input(prompt_prefix, last_dt, printer)
            if isinstance(dt_inp, datetime):
                printer("using timestamp {} for current metric only".format(dt_inp))
                dt_custom = dt_inp
            elif isinstance(dt_inp, InputCancel):
                printer("timestamp entry canceled")
        elif isinstance(inp, SpecialValue):
            raise Exception("unexpected SpecialValue: " + str(inp))
        else:
            val = inp
            break # main entry loop

    if valtype == int and last_val:
        delta = " ({:+})".format(val - last_val)
    else:
        delta = ""

    ts = int(dt.replace(tzinfo=timezone.utc).timestamp())
    rows.append((ts, val))
    write_csv(path, rows)
    printer("saved: time {}, value {}{}".format(dt, val, delta))


def entry_path(root):
    for fp in file_paths_sorted(root, pred=is_numeric_type,
                                filter_root=True, error=False):
        entry_file(fp)


def cmd_entry(args):
    """Enter data manually in an interactive session.

    You will be prompted to enter data points one by one for each
    applicable file. After collecting the input value, UTC timestamp
    will be generated and appended to the end of file together with the
    new value. Make sure your system clock is accurate.

    To protect from errors, you will be prompted to enter each value
    twice.

    To skip entering current value, enter a blank line twice or hit
    Ctrl-D (Ctl-Z+Return on Windows).

    To enter the timestamp manually, enter ':t' instead of the value.

    To quit the data entry session, hit Ctrl-C.
    """
    print("Interactive data entry mode. Make sure your system clock is accurate.")
    print("Your system UTC time is:",
          format(datetime.utcfromtimestamp(int(time.time()))))
    pathlist = args.pathlist
    if pathlist:
        for path in load_list(pathlist):
            entry_path(path)
    else:
        entry_path(args.path)


def make_arg_parser():
    import argparse

    file_types_str = ", ".join(Const.int_exts + Const.float_exts + Const.str_exts)
    parser = argparse.ArgumentParser(
        description=("time series utility. The following file types are"
                     " supported: " + file_types_str))
    subparsers = parser.add_subparsers(dest="command", title="commands")

    listaccs = subparsers.add_parser(
        "listaccs", aliases=["la"],
        help="list accounts in the data directory")
    listaccs.set_defaults(func=cmd_list_accounts)

    validate = subparsers.add_parser(
        "validate", aliases=["val"],
        help="validate time series files")
    validate.add_argument(
        "path", nargs="?",
        default=Config.data_dir,
        help="path to search time series files")
    validate.set_defaults(func=cmd_validate)

    view = subparsers.add_parser(
        "view", aliases=["v"],
        help="view one or more time series files")
    view.add_argument(
        "path",
        help="path to view")
    view.add_argument(
        "-l", "--limit",
        help="max number of records to output for each file")
    view.set_defaults(func=cmd_view)

    latest = subparsers.add_parser(
        "latest",
        help="print latest values for metrics listed in a file")
    latest.add_argument(
        "metriclist",
        help="list file with metric files, one per line")
    latest.set_defaults(func=cmd_latest)

    export = subparsers.add_parser(
        "export",
        help="export data into a single CSV file",
        description=("Export data from arbitrary tree of time series files"
                     " into a single file (" + Config.export_filename +
                     " by default), overwriting it."))
    export_src = export.add_mutually_exclusive_group(required=True)
    export_src.add_argument(
        "path", nargs="?",
        default=Config.data_dir,
        help="path to search time series files in")
    export_src.add_argument(
        "-p", "--pathlist",
        help="list file with paths to export data points from, one per line")
    export.add_argument(
        "--output",
        default=Config.export_filename,
        help="file name to save")
    export.set_defaults(func=cmd_export_csv)

    entry = subparsers.add_parser(
        "entry", aliases=["e"],
        help="enter data manually",
        description=cmd_entry.__doc__)
    entry_target = entry.add_mutually_exclusive_group(required=True)
    entry_target.add_argument(
        "path", nargs="?",
        default=Config.data_dir,
        help="file or directory path to enter data in; if directory, the"
             " program will prompt data entry for each time series file found"
             " in it")
    entry_target.add_argument(
        "-p", "--pathlist",
        help="list file with paths to enter data in, one path per line")
    entry.set_defaults(func=cmd_entry)

    return parser


def main():
    parser = make_arg_parser()
    args = parser.parse_args()

    if args.command:
        try:
            args.func(args)
        except (TsuError, FileNotFoundError) as e:
            print("error:", e)
        except KeyboardInterrupt:
            print("\naborting")
        except BrokenPipeError:
            # silence error when e.g. piping into `less` and quitting before
            # reading all
            pass
    else:
        parser.print_usage()


if __name__ == "__main__":
    main()
